<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>面向对象</h1>
</body>
<script src="./index.js"></script>
<script>
    // 创建对象的三种方式
    var obj1 = { message: 'success', status: '200' }; // 字面量创建
    var obj2 = new Object({ message: 'redirect', status: '301' }); // 通过 new 与 构造函数创建
    var obj3 = Object.create({ message: 'server error', status: '502' }); // 通过 api 创建

    function Dog (name, color) {
        this.color = color;
        this.name = name;
    }
    var charis = new Dog('巴豆', 'white');
    console.log(charis.__proto__ === Dog.prototype);
    console.log(Dog.prototype.__proto__ === Object.prototype);
    console.log(Object.prototype.__proto__ === null);
    console.log(Dog.prototype.constructor === Dog);

    var spy = { name: '谍影重重' };
    var msg = Object.create(spy);
    console.log(msg.__proto__ === spy);
    console.log(spy.__proto__ === Object.prototype);

    /** 
     * 构造函数、实例、原型对象三者关系
     * 实例.__proto__ → 原型对象
     * 构造函数.prototype → 原型对象
     * 原型对象.constructor → 构造函数
     * 原型对象.__proto__ → others(如 Object.prototype，尽头是 null)
    */
    var num = new Number(10);
    console.log(num.__proto__ === Number.prototype);
    console.log(Number.prototype.__proto__ === Object.prototype);
    console.log(Object.prototype.__proto__ === null);

    /** 
     * new 运算符做了哪些事？
     * 1. 创建一个空对象；
     * 2. 使该对象的原型指向构造函数的原型(继承构造函数的原型)；
     * 3. 构造函数执行；
     * 4. 改变 this 的指向；
     * 5. 返回新对象(构造函数无返回值时)；
     * 
     * 如何设计构造函数能兼容创建实例时漏写 new 的情况发生？
    */
    function Cat (type, age) {
        this.type = type;
        this.age = age;

        if (!(this instanceof Cat)) {
            return new Cat(type, age);
        }
    }
    var c1 = new Cat('蓝猫', '3month');
    var c2 = Cat('曼康基', '2month');
</script>
</html>